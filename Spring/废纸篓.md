# 废纸篓

# Spring boot

## 怎么禁用某些自动配置特性？

如果我们想禁用某些自动配置特性，可以使用 @EnableAutoConfiguration 注解的 exclude 属性来指明。例如，下面的代码段是使 DataSourceAutoConfiguration 无效：

```
// other annotations
@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
```

如果我们使用 @SpringBootApplication 注解 — 那个将 @EnableAutoConfiguration 作为元注解的项，来启用自动化配置，我们能够使用相同名字的属性来禁用自动化配置：

```
// other annotations
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
```

我们也能够使用 spring.autoconfigure.exclude 环境属性来禁用自动化配置。application.properties 中的这项配置能够像以前那样做同样的事情：

```
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

## 怎么注册一个定制的自动化配置？

为了注册一个自动化配置类，我们必须在 META-INF/spring.factories 文件中的 EnableAutoConfiguration 键下列出它的全限定名：

```
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.baeldung.autoconfigure.CustomAutoConfiguration
```

如果我们使用 Maven 构建项目，这个文件需要放置在在 package 阶段被写入完成的 resources/META-INF 目录中。



## 怎么使用 SpringBoot 去执行命令行程序？

像其他 Java 程序一样，一个 SpringBoot 命令行程序必须要有一个 main 方法。这个方法作为一个入口点，通过调用 SpringApplication#run 方法来驱动程序执行：

```
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class);
        // other statements
    }
}
```

SpringApplication 类会启动一个 Spirng 容器以及自动化配置 beans。

要注意的是我们必须把一个配置类传递到 run 方法中作为首要配置资源。按照惯例，这个参数一般是入口类本身。

在调用 run 方法之后，我们可以像平常的程序一样执行其他语句。

## 有什么外部配置的可能来源？

SpringBoot 对外部配置提供了支持，允许我们在不同环境中运行相同的应用。我们可以使用 properties 文件、YAML 文件、环境变量、系统参数和命令行选项参数来声明配置属性。

然后我们可以通过 @Value 这个通过 @ConfigurationProperties 绑定的对象的注解或者实现 Enviroment 来访问这些属性。

以下是最常用的外部配置来源：

-   命令行属性：命令行选项参数是以双连字符（例如，=）开头的程序参数，例如 –server.port=8080。SpringBoot将所有参数转换为属性并且添加到环境属性当中。
-   应用属性：应用属性是指那些从 application.properties 文件或者其 YAML 副本中获得的属性。默认情况下，SpringBoot会从当前目录、classpath 根目录或者它们自身的 config 子目录下搜索该文件。
-   特定 profile 配置：特殊概要配置是从 application-{profile}.properties 文件或者自身的 YAML 副本。{profile} 占位符引用一个在用的 profile。这些文件与非特定配置文件位于相同的位置，并且优先于它们。



## 什么是 FreeMarker 模板？

FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。



## SpringBoot 支持松绑定代表什么？

SpringBoot中的松绑定适用于配置属性的类型安全绑定。使用松绑定，环境属性的键不需要与属性名完全匹配。这样就可以用驼峰式、短横线式、蛇形式或者下划线分割来命名。

例如，在一个有 @ConfigurationProperties 声明的 bean 类中带有一个名为 myProp 的属性，它可以绑定到以下任何一个参数中，myProp、 my-prop、my_prop 或者 MY_PROP。

## SpringBoot 中如何解决跨域问题 ?

跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 SpringBoot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。

@Configuration public class CorsConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry、addMapping("/**") 、allowedOrigins("*") 、allowCredentials(true) 、allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") 、maxAge(3600); } }



## spring boot监听器流程?

**1、** 通过`app.addListeners`注册进入 2、初始化一个`SpringApplicationRunListeners`进行处理

**3、** 从`spring.factories`中读取监听器处理类`EventPublishingRunListener`

**4、** 通过`createSpringFactoriesInstances`创建监听器处理类实例

**5、** 调用监听器`listeners.starting()`的方法来启动。

**6、** 底层把事件处理交给`线程池`去处理

## 什么是执行器停机？

关机是允许应用程序正常关机的端点。默认情况下，此功能不启用。你可以在应用程序属性文件中使用management . endpoint . shut down . enabled = true来启用此选项。但是该方法请谨慎使用。

## RequestMapping 和 GetMapping 的不同之处在哪里？

RequestMapping 具有类属性的，可以进行 GET,POST,PUT 或者其它的注释中具有的请求方法。

GetMapping 是 GET 请求方法中的一个特例。它只是 ResquestMapping 的一个延伸，目的是为了提高清晰度。

## SpringBoot 如何设置支持跨域请求？

现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。

**一般前端的解决方案有：**

**1、** 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建`<script>`标签，然后利用`<script>`的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。

**2、** 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。

后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。

前端使用了 CORS 协议，就需要后端设置支持非同源的请求，SpringBoot 设置支持非同源的请求有两种方式。

第一，配置 CorsFilter。

@Configuration public class GlobalCorsConfig { @Bean public CorsFilter corsFilter() { CorsConfiguration config = new CorsConfiguration(); config.addAllowedOrigin("*"); config.setAllowCredentials(true); config.addAllowedMethod("*"); config.addAllowedHeader("*"); config.addExposedHeader("*"); UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); return new CorsFilter(configSource); } }

需要配置上述的一段代码。第二种方式稍微简单一些。

第二，在启动类上添加：

public class Application extends WebMvcConfigurerAdapter { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowCredentials(true) .allowedHeaders("*") .allowedOrigins("*") .allowedMethods("*"); } }



## Spring Boot ⽀持哪些内嵌 [Servlet](https://so.csdn.net/so/search?q=Servlet&spm=1001.2101.3001.7020) 容器？

-   Tomcat
-   Jetty
-   Undertow

## 如何在 Spring Boot 应⽤程序中使⽤ Jetty ⽽不是 Tomcat?

去除Tomcat相关依赖，然后引入Jetty 的依赖

## 介绍⼀下@SpringBootApplication 注解

-   @SpringBootApplication =@SpringBootConfiguration + @EnableAutoConfiguration + @ComponentScan
-   @SpringBootConfiguration：主要包含了@Configuration注解
-   @EnableAutoConfiguration：开启自动配置，@Import加载符合条件的Bean
-   @ComponentScan：自动扫描加载符合条件的Bean

## 开发 [RESTful](https://so.csdn.net/so/search?q=RESTful&spm=1001.2101.3001.7020) Web 服务常⽤的注解有哪些？

-   @RestController
-   @GetMapping
-   @PostMapping
-   @PutMapping
-   @DeleteMapping
-   @PatchMapping

## 常⽤的 Bean 映射⼯具有哪些？

-   BeanUtils：apache和spring
-   BeanCopier：cglib

-    

## **什么是 JavaConfig？**

**1、** `面向对象的配置`。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的[面向对象](https://so.csdn.net/so/search?q=面向对象&spm=1001.2101.3001.7020)功能。一个配置类可以继承另一个，重写它的@Bean 方法等。

**2、** `减少或消除 XML 配置`。基于[依赖注入](https://so.csdn.net/so/search?q=依赖注入&spm=1001.2101.3001.7020)原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。

**3、** `类型安全和重构友好`。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。



### **SpringBoot中如何解决跨域问题 ?**

跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。

```javascript
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .maxAge(3600);
    }
}
```

项目中前后端分离部署，所以需要解决跨域的问题。我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。

```javascript
@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();
        urlBasedCorsConfigurationSource.registerCorsConfiguration("/**", corsConfiguration);
        return new CorsFilter(urlBasedCorsConfigurationSource);
    }
}
```

## 如何集成Spring Boot和ActiveMQ？

对于集成Spring Boot和ActiveMQ，我们使用spring-boot-starter-activemq 依赖关系。它只需要很少的配置，并且不需要样板代码。

### **SpringBoot、Spring MVC和Spring有什么区别？**

-   **Spring**Spring最重要的特征是依赖注入。所有Spring Modules不是依赖注入就是IOC控制反转。当我们恰当的使用DI或者是IOC的时候，可以开发松耦合应用。
-   **Spring MVC**Spring MVC提供了一种分离式的方法来开发Web应用。通过运用像DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。
-   **SpringBoot**Spring和Spring MVC的问题在于需要配置大量的参数。SpringBoot通过一个自动配置和启动的项来解决这个问题。



###  **SpringBoot的核心注解是什么？由那些注解组成？**

启动类上@SpringBootApplication是 SpringBoot 的核心注解

```javascript
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
```

复制

主要组合包含了以下 3 个注解：

-   @**SpringBootConfiguration**：组合了 @Configuration 注解，实现配置文件的功能。
-   @**EnableAutoConfiguration**：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
-   @**ComponentScan**：Spring组件扫描。

## Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

@ComponentScan：Spring组件扫描。

## 什么是JavaConfig？

Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：

-   面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。

-   减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。

-   JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。

-   从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。
-   类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找。



### **SpringBoot 中如何实现定时任务?**

定时任务也是一个常见的需求，SpringBoot 中对于定时任务的支持主要还是来自 Spring 框架。

在 SpringBoot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。

-   使用Spring中的 @Scheduled的方式主要通过@Scheduled注解来实现。
-   使用Quartz，则按照Quartz的方式，定义Job和Trigger即可。

###  **微服务中如何实现 session 共享?**

在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。

## Spring Boot中的监视器是什么？

Spring boot actuator是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。

有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。

## 如何在Spring Boot中禁用Actuator端点安全性？

默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。

安全性是使用标准的HttpServletRequest.isUserInRole方法实施的。我们可以使用management.security.enabled = false 来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。

### **如何在SpringBoot中禁用Actuator端点安全性？**

默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准的`HttpServletRequest.isUserlnRole` 方法实施的。我们可以使用`management.security.enabled=false`来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。



## 如何实现Spring Boot应用程序的安全性？

为了实现Spring Boot的安全性，我们使用 spring-boot-starter-security依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter并覆盖其方法。



## 如何使用Spring Boot实现分页和排序？

使用Spring Boot实现分页非常简单。使用Spring Data-JPA可以实现将可分页的org.springframework.data.domain.Pageable传递给存储库方法。

## 保护 Spring Boot 应用有哪些方法？

在生产中使用HTTPS

使用Snyk检查你的依赖关系

升级到最新版本

启用CSRF保护

使用内容安全策略防止XSS打击

…

## 比较一下 Spring Security 和 Shiro 各自的优缺点 ?

由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：

1.  Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架
2.  Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单
3.  Spring Security 功能强大；Shiro 功能简单

注：Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理

## Spring Boot 中的监视器是什么

因为SpringBoot简单配置即可使用，对底层封装的比较严实，所以发现错误不太好找bug。所以我们需要监控项目的某些状态信息来方便找bug。Spring Boot提供您的项目监控组件是 Spring Boot Actuator。   

  \- Endpoints:监控应用的入口，Spring Boot内置很多端点， 通过@EndPoints()注解即可自定义端点

  \- 监控方式：HTTP 或者 JMX

  \- 访问路径：例如："/actuator/health"

  \- 注意事项：按需配置暴露的端点(一共20多个端点）、需要通过Spring Security对所有端点进行权限控制，只有管理员可以访问，否则任何人都可以访问底层的代码，很不安全。



## 前后端分离，如何维护接口文档 ?

前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。

## 如何使用 Spring Boot 实现异常处理？

通过@ControllerAdvice、@ExceptionHandler、@ModelAttribute、@DataBinder 4个注解来统一处理控制器类抛出的所有异常。

@ControllerAdvice：用于修饰类，表示该类是Controller的全局配置类。

 在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。

 @ExceptionHandler（异常处理方案）：用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。
 @ModelAttribute（绑定数据方案）：用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。
 @DataBinder（绑定参数方案）： 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。

## Spring Boot 中如何实现定时任务 ?

在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，这个注解使用的是ThreadPoolTaskScheduler来实现的。在需要定时执行的方法上加上 @Scheduled 注解来实现。编码简单。
另一个则是使用第三方框架 Quartz。实现过程中需要按照 Quartz 的方式，定义 Job 和 Trigger。编码复杂。

其中@Scheduled方式在分布式环境中会有重复执行的问题，但是Quartz在分布式环境中没问题，因为Quartz会创建专有数据库，如果发现数据库中有相同任务在执行会放弃执行当前任务，这样任务就不会被重复执行。

## Spring Boot 可以兼容老 Spring 项目吗，如何做？

可以兼容，使用 @ImportResource 注解导入老 Spring 项目配置文件。



## 我们如何监视所有 Spring Boot 微服务？

Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。

## SpringBoot 需要独立的容器运行吗？

## 如何禁用一个特定自动配置类？

## 微服务中如何实现 session 共享

## 如何使用 Spring Boot 实现分页和排序？
