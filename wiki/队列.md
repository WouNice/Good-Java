# 队列

![image-20220712215323194](assets/image-20220712215323194.png)

如上图所示，队列是典型的 FIFO 数据结构。新元素始终被添加在队列的末尾。

Java中队列基本操作

| 操作    | 动作                     | 行为                                               |
| ------- | ------------------------ | -------------------------------------------------- |
| offer   | 添加一个元素并返回true   | 如果队列已满，则返回false                          |
| poll    | 移除并返问队列头部的元素 | 如果队列为空，则返回null                           |
| peek    | 返回队列头部的元素       | 如果队列为空，则返回null                           |
| add     | 增加一个元索             | 如果队列已满，则抛出一个IIIegaISlabEepeplian异常   |
| remove  | 移除并返回队列头部的元素 | 如果队列为空，则抛出一个NoSuchElementException异常 |
| element | 返回队列头部的元素       | 如果队列为空，则抛出一个NoSuchElementException异常 |

## 顺序队列

![](assets/image-20220712215823064.png)

## 链式队列

![](assets/image-20220712215839649.png)

## 循环队列

![](assets/image-20220712215910626.png)

## 双端队列

![](assets/image-20220712215939815.png)

## 优先队列

-   一种不必遵循队列先进先出(FIFO)特性的特殊队列
-   每次入队时，都会按照入队数据项的关键值进行排序(从大到小、从小到大)，这样保证了关键字最小的或者最大的项始终在队头，出队的时候优先级最高的就最先出队

![](assets/image-20220712220043398.png)

Java对应实现

```
Queue<Integer> queue = new PriorityQueue<Integer>();
```

## 队列和BFS

![](assets/image-20220712220133435.png)

结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因

## 完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

![](assets/image-20220712220259938.png)

-   示例 1:输入: n = 12
-   输出: 3 
-   解释: 12 = 4 + 4 + 4.



-   示例 2:输入: n = 13
-   输出: 2
-   解释: 13 = 4 + 9.

```
 private class Node {
    int val;
    int step;

    public Node(int val, int step) {
        this.val = val;
        this.step = step;
    }
}
```

```
public int numSquares(int n) {
    Queue<Node> queue = new LinkedList<>();
    int[] vis = new int[n+1];
    queue.offer(new Node(n,0));
    while(!queue.isEmpty()){
        Node temp = queue.poll();
        int num = temp.val;
        int step = temp.step;
        for (int i = 1;; i++) {
            int val = num - i*i;
            if(val<0){
                break;
            }
            if(val==0){
                return step+1;
            }
            if(vis[val]==0){
                vis[val] = 1;
                queue.offer(new Node(val,step+1));
            }
        }
    }
    return -1;
}
```

## 队列题型

实现队列

-   用栈实现队列
-   设计循环队列
-   设计循环双端队列

应用队列原理解题

-   用队列实现栈
-   任务调度器
-   二叉树的层次遍历
-   前 K 个高频元素
-   广度搜索(BFS)——LeetCode专题
